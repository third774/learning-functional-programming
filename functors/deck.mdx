import { List, ListItem } from "../components/List";
export { default as theme } from "../theme/theme";

# 𝝺

# Functors

```notes
Our topic today is: Functors!


```

---

### JS
```js
const items = [1, 2, 3]
const squared = items.map(x => x * x)
// [1, 4, 9]
```

### Python
```python
items = [1, 2, 3]
squared = list(map(lambda x: x**2, items))
# [1, 4, 9]
```

```notes
We should probably start with a concrete example that everybody is probably familiar with - map. This is also called Select in LINQ for anyone familiar with C#.

Map is a higher order function that lets us take an array of things and apply some transformation on each item in the array and get a new array with those transformations applied.

There are a few functor laws that we'll cover today, but structures that have this map operation on it usually are functors.
```

---

### Caveat

Technically, the functor is the transformation itself, not the data structure.

```notes
Quick caveat. In math - the function itself is the functor. In programming, however, we are usually talking about data structures that have this map operation available them.
```

---

```haskell
-- map :: (a -> b) -> [a] -> [b]
map (^2) [1, 2, 3]
-- [1, 3, 9]
```

```notes
Let's take another look at map but in Haskell and see the type signature. We have an (a -> b) function, and then a list of a's, and we get a list of b's.

So, we don't know anything about types a and b except that they may be different, and we have that (a -> b) function. 
We could be taking a list of users and producing a list of their first names. We could take a list of numbers and square them.

Note here, that while the types contained within the array can change, it MUST still be an array.
```
